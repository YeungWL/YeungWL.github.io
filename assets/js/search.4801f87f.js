(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{352:function(e,t,r){"use strict";r.r(t),t.default=[{title:"【小技巧】判断是否是对象(数组)",path:"/posts/skill-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E5%AF%B9%E8%B1%A1(%E6%95%B0%E7%BB%84).html",strippedContent:' JavaScript中检测对象的方法 ### 新手章 1. typeof操作符  这种方法对于一些常用的类型来说那算是毫无压力，比如Function、String、Number、Undefined等，但是要是检测Array的对象就不起作用了。 利用typeof除了array和null判断为object外，其他的都可以正常判断 ```js alert(typeof null); // "object" alert(typeof function () { return 1; }); // "function" alert(typeof \'梦龙小站\'); // "string" alert(typeof 1); // "number" alert(typeof a); // "undefined" alert(typeof undefined); // "undefined" alert(typeof []); // "object" ```  2. instanceof操作符   这个操作符和JavaScript中面向对象有点关系，了解这个就先得了解JavaScript中的面向对象。因为这个操作符是检测对象的原型链是否指向构造函数的prototype对象的。 ```js // Array var arr = [1,2,3,1]; arr instanceof Array; // true  // Object var obj = {name: \'Yeung\'}; obj instanceof Object; // true ```  3. 对象的constructor属性  除了instanceof，每个对象还有constructor的属性，利用它似乎也能进行Object/Array的判断。 ```js // Array var arr = [1,2,3,1]; arr.constructor === Array; // true  // Object var obj = {name: \'Yeung\'}; obj.constructor === Object; // true ``` > 第2种和第3种方法貌似无懈可击，但是实际上还是有些漏洞的，当你在多个frame中来回穿梭的时候，这两种方法就亚历山大了。由于每个iframe都有一套自己的执行环境，跨frame实例化的对象彼此是不共享原型链的，因此导致上述检测代码失效  ```js var iframe = document.createElement(\'iframe\'); //创建iframe document.body.appendChild(iframe); //添加到body中 xArray = window.frames[window.frames.length-1].Array; var arr = new xArray(1,2,3); // 声明数组[1,2,3] alert(arr instanceof Array); // false alert(arr.constructor === Array); // false  ```  ### 最终章    1. Object.prototype.toString    Object.prototype.toString的行为：首先，取得对象的一个内部属性[[Class]]，然后依据这个属性，返回一个类似于"[object Array]"的字符串作为结果(看过ECMA标准的应该都知道，[[]]用来表示语言内部用到的、外部不可直接访问的属性，称为“内部属性”)。利用这 个方法，再配合call，我们可以取得任何对象的内部属性[[Class]]，然后把类型检测转化为字符串比较，以达到我们的目的。  ```js function isArrayFn (o) {     return Object.prototype.toString.call(o) === \'[object Array]\'; // Object [object Object] } var arr = [1,2,3,1]; alert(isArrayFn(arr));// true  ``` call改变toString的this引用为待检测的对象，返回此对象的字符串表示，然后对比此字符串是否是\'[object Array]\'，以判断其是否是Array的实例。为什么不直接o.toString()?嗯，虽然Array继承自Object，也会有 toString方法，但是这个方法有可能会被改写而达不到我们的要求，而Object.prototype则是老虎的屁股，很少有人敢去碰它的，所以能一定程度保证其“纯洁性”  JavaScript 标准文档中定义: [[Class]] 的值只可能是下面字符串中的一个： Arguments, Array, Boolean, Date, Error, Function, JSON, Math, Number, Object, RegExp, String.   这种方法在识别内置对象时往往十分有用，但对于自定义对象请不要使用这种方法。 '},{title:"【零散的知识】brew下载指定的node版本",path:"/posts/scatter-brew%E4%B8%8B%E8%BD%BD%E6%8C%87%E5%AE%9A%E7%9A%84node%E7%89%88%E6%9C%AC.html",strippedContent:" mac环境下,使用homebrew 安装的node, 默认是最高版本,命令如下:  ```bash brew install node ``` 那么使用homebrew如何安装指定版本的node呢?  1. 如果之前使用**brew install node**安装过node,需要先执行**brew unlink node**来'解绑'node 2. 查找可用的node版本 **brew search node** 3. 安装你需要的版本, 比如 **brew install node@12** 4. 然后 **brew link node@8**, 这一步可能会报错, 按照提示执行命令就ok了, 比如我最后执行的是**brew link --overwrite --force node@12** 5. **node -v** 不出意外, 就安装好了你想要的node版本 "},{title:"【vue】组件之间的通信",path:"/posts/vue-%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1.html",strippedContent:" ### 1、父与子通信 （props down） ```js     1.发送         <son myName='zhangsan'>         </son>     2.接受         到son组件：         Vue.component('son',{           props:['myName'],           template:`            <p>{{myName}}</p>           `         }) ```      ### 2、子与父通信 (events up) ```js     1.绑定     methods:{      handleEvent:function(msg){}     }     <son @customEvent=\"handleEvent\"></son>     2.触发     子组件内部：     this.$emit(‘customEvent’,100); ```  ### 3、ref(reference 引用/参考 外号)  帮助在父组件中 得到子组件中的数据、方法。 ```js     1.指定ref属性     <son ref=\"mySon\"></son>      2.根据ref得到子组件实例     this.$refs.mySon ```  ### 4、$parent ```js     this.$parent得到父组件的实例 ```  ### 5、兄弟组件通信 ```js     1.var bus = new Vue();     2.接收方     bus.$on('eventName',function(msg){})     3.发送方     bus.$emit('eventName',123); ``` "},{title:"【零散的知识】GitHub配置ssh",path:"/posts/scatter-github%E9%85%8D%E7%BD%AEssh.html",strippedContent:" ### 1. 打开本地git bash,使用如下命令生成ssh公钥和私钥对 ```bash ssh-keygen -t rsa -C 'xxx@xxx.com' 然后一路回车(-C 参数是你的邮箱地址) ```  ### 2. 然后会出现：Enter file in which to save the key (/Users/yzq/.ssh/id_rsa): ``` 回车 ```  ### 3. 如果你的.ssh/id_rsa已经生成过，则会出现：/Users/yzq/.ssh/id_rsa already exists. Overwrite (y/n)? y ``` 输入：y  （重新覆盖） 输入：n  （不覆盖） ```  ### 4. 设置你的密码（位数不要太短，尽量设置6位） --也可以不用设置密码 详细如下图 ![image](/ssh.jpeg)  ### 5. 现在只需要查看本机ssh公钥，获取得到它 ```bash cd ~/.ssh ls（查看目录是否有id_rsa.pub文件） 查看公钥：cat id_rsa.pub    或者vim id_rsa.pub ``` 详细如下图 ![image](/ssh-key.jpeg)  ### 6. 配置GitHub > 获取到的那一大段，就是我们需要的ssh key，复制下来,包括前面和后面的，给到下图配置，即可完成GitHub(GitLab...都类似)配置ssh key  ![image](/github.jpeg) "},{title:"【零散的知识】shell常用指令",path:"/posts/scatter-shell%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4.html",strippedContent:" ### 1. 文件夹操作 ~~~bash # 创建文件夹 mkdir 文件夹名称 ...  // directory 目录 支持创建多个  # 进入文件夹 cd 目标文件夹   // change 改变  # 删除空文件夹 rmdir 文件夹名称  // remove 更改  # 查看当前路径 pwd   # 查看当前目录 ls     //列举文件 ls -l  // 以列表的形式展示目录 ls -a  // 展示全部目录 ~~~  ### 2. 文件操作 ```bash # 创建文件 touch 文件名 ...  // 支持创建多个  # 复制文件 cp  文件名称  新文件名称     # cp index.html js/index1.html  # 移动文件（相当于剪切） mv  文件名称  目标目录     # mv index.html css/pipixia.html    // 移动的同时，修改文件名称     # mv index.html demo.html    // 重命名  # 删除文件 rm 文件名称     # rm -r css  //  递归删除,删除css文件夹里所有文件然后删除自身  # 查看文件 cat 文件名称     # cat id_rsa.pub // 查看文件内容 ```"},{title:"【零散的知识】vsCode定义路径有提示",path:"/posts/scatter-vscode%E5%AE%9A%E4%B9%89%E8%B7%AF%E5%BE%84%E6%9C%89%E6%8F%90%E7%A4%BA.html",strippedContent:' - Path Intellisense  定义自定义路径别称 ```json {     "path-intellisense.mappings": {         "@": "${workspaceRoot}",         "components": "${workspaceRoot}/components"     } } ```  > 因为每个项目不一样, 建议是再项目文件夹下新建.vscode/settings.json '},{title:"【vue】实现点击后动态添加class及删除同级class",path:"/posts/vue-%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0class%E5%8F%8A%E5%88%A0%E9%99%A4%E5%90%8C%E7%BA%A7class.html",strippedContent:' 场景：当需求在多个相同的items里面，点击的items变成选中的样式，其他的items恢复原来的模样  直接上代码 ```html   <div class="container">     <ul>       <li v-for="(item,i) in showItem"           :key="item.id"           :class="[\'show-item\',{active:i == actionIndex}]"            @click="handelActiveIndex(i)">选项1</li>     </ul>   </div> ```  ```js export default {   name:\'showList\',   data() {     actionIndex: 0 ,// 控制点亮状态,也是对应数组的下标     showItem:[]   },   methods:{     handelActiveIndex(index){// 点击添加类名删除同级类名的方法       this.activeIndex = index;     }   } } ```  > 1. class名中 show-item是固定的, active是根据循环的下标(i)和选中更改的activeIndex对应为true才显示 > 2. 渲染的li的下标如果跟改变的activeIndex下标一致 就是为true'},{title:"【零散的知识】JavaScript中的短路(易忘)",path:"/posts/scatter-JavaScript%E4%B8%AD%E7%9A%84%E7%9F%AD%E8%B7%AF.html",strippedContent:" ### 逻辑与(&&) ```js 1. var a = 0 && 3 // a == 0  2. var b = 2 && 0  // b == 0  3. var c = 3 && false  // c == false  4. var d = 2 && 3  // d == 3  5. var e = 2 && 3 && 4  //  e == 4  6. var f = 2 && false && 0  // f == false  ``` > 表达式中有条件为false的表达式，返回第一个条件为false的表达式的值。没有则返回最后一个表达式的值。  ### 逻辑或(||) ```js 1. var a = 0 || 3  // a == 3  2. var b = 2 || 0  // b == 2  3. var c = 3 || false  // c == 3  4. var d = 2 || 3  // d == 2  5. var e = 0 || 3 || 4  // e == 3  6. var f = 0 || false || null  // f == null  ``` > 表达式中有条件为true的表达式，返回第一个条件为true的表达式的值。没有则返回最后一个表达式的值  ``` 转换规则: 1. 对象为true 2. 非零数字为true 3. 非空字符串为true 4. 其他为false ```"},{title:"【vue】设置浏览器标题(spa)",path:"/posts/vue-%E8%AE%BE%E7%BD%AE%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A0%87%E9%A2%98(spa).html",strippedContent:" ### 1. vue的指令来设置标题   在main.js中设置 ~~~js // 设置浏览器标题 Vue.directive('title', {   inserted: (el) => {     document.title = el.dataset.title   } }) ~~~  在各个页面的根标签设置（template下的） ```html   <div class=\"rel-container\" v-title data-title=\"登录\"></div> ```  ### 2. 使用插件 (微信等APP里面也可以生效)  ~~~bash npm i vue-wechat-title -S ~~~  在main.js中加入 ```js import vueWechatTitle from 'vue-wechat-title' vue.use(vueWechatTitle) ```  在路由(router)下面加上title ~~~js {     path: '/login',     name: 'login',     component: () => import('views/login/login.vue'),     meta; {         title: '登录'     } } ~~~  在根的router-view上, 加上组件的指令 ```html <router-view v-wechat-title=\"$router.meta.title\"></router-view> ```  插件的原理也是document.title"},{title:"【vue】设置路由守卫防止没有登录跳转",path:"/posts/vue-%E8%AE%BE%E7%BD%AE%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB%E9%98%B2%E6%AD%A2%E6%B2%A1%E6%9C%89%E7%99%BB%E5%BD%95%E8%B7%B3%E8%BD%AC.html",strippedContent:" 创建一个全局注册的守卫  ```js const router = new Router({...}) router.beforeEach((to, from, next) => {     // ... }) ```  > 每一个守卫接收的三个参数 > 1. to: 即将要进入的目标 路由对象 > 2. from: 当前导航正要离开的路由 > 3. next: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。 >       - next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed （确认的）。 >       - next(false): 中断当前的导航。如果浏览器的 URL 改变了（可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置到 from 路由对应的地址。 >       - next('/') 或者 next({ path: '/' }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。 >       - next(error): (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。  代码展示  router文件夹下 放了两个文件 index.js 和 routes.js  index.js ```js import Vue from 'vue' import Router from 'vue-router' import store from 'store' import { routers } from './router' Vue.use(Router)  // 路由器配置 const RouterConfig = {   routes: routers }  // 把路由暴露出去 export const router = new Router(RouterConfig)  // 声明一个白名单列表, 作为判断页面使用 const whiteList = ['/login', '/404']  // 路由守卫 router.beforeEach((to, from, next) => {     // NProgress.start() // 进度条     // 判断vuex里面是否有token -- 使用vuex来判断是否登录过比较好 vuex就是vue的状态保持仓库 store里面的内容     if(store.getters.token) { // 判断到vuex里面有保持到token         if(to.path === '/login' || ...) { // 判断是否是登录页面或者其他一些登录之前操作的页面(例如:注册页面) 如果是不用再做登录直接跳转的主页面             next({path: '/index'})         }else {             next()         }     }else { // 判断到vuex里面没有保持到token         if(whiteList.indexOf(to.path) !== -1) { // array.indexOf()方法返回在该数组中第一个找到的元素位置，如果它不存在则返回-1。             // 判断现有页面里面如果包含白名单的 就跳转页面             next()         }else { // 判断跳转页面不是白名单里面的就跳转登录页面做登录             next({path : '/login'})             // NProgress.done()         }     } }   router.afterEach(_ => {   window.scrollTo(0, 0)   // NProgress.done() }) ```  routes.js ```js export const routers = [     {         path: '/login',         component: () => import('views/login/index'),         name: '登录',                  .....     }          ..... ] ```"},{title:"【vue】vue中的使用formData完成上传",path:"/posts/vue-%E4%BD%BF%E7%94%A8formData%E5%AE%8C%E6%88%90%E4%B8%8A%E4%BC%A0.html",strippedContent:' ## 完成上传的操作   思路如下：  ### 1. 页面上写一个type=\'file\'的input标签 是隐藏的 绑定一个ref属性  ```html <input type="file"        name="file"        ref="file"        @change="handleFileChange"        style="display:none"> ``` ```js handleFileChange(e) {     let file = e.target.files[0]     this.fileName = file.name     this.file = file } ```  2. 页面上有一个按钮，点击按钮让他去触发input标签  ~~~html <el-button size="small"            type="primary"            @click="handleUploadFile">上传文件</el-button> ~~~ ~~~js javaScript: handleUploadFile(){     this.$refs.file.click() } ~~~  ### 3. 由于发送ajax请求，带文件过去文件会变成文档的字符节流  ### 4. 所以会用到FormData来完成上传  ~~~js handleImport() {     let formData = new FormData()     formData.append(\'devices\', this.file)     this.$api.asset.importDevice(formData).then(response => {         if (response.success) {           // 判断成功           this.$message.success(\'导入成功\')         } else {           // 判断失败           this.$message.error(response.message)         }     }) } ~~~'},{title:"【vue】vue中事件修饰符：stop prevent self capture",path:"/posts/vue-%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6.html",strippedContent:' vue提倡的是在方法中只有对数据的处理，所以提供了事件修饰符用于DOM的事件处理，常用的事件修饰符有以下几个:  统一的js ```js <script> export default {   methods:{     divEven(){       alert("我是div的事件");     },     aEven(){       alert("我是a链接事件");     }   } } <\/script> ```  ### 1. 第一种情况 ```html   \x3c!--第一种情况--\x3e   <div @click="divEven" style="border:1px #188eee solid;">       <a href="#" @click="aEven">百度链接</a>   </div> ``` ### 2. stop的使用：阻止事件冒泡的发生 ```html \x3c!--stop的使用：阻止事件冒泡的发生--\x3e <div @click="divEven" style="border:1px #188eee solid;">     <a href="#" @click.stop="aEven">百度链接</a> </div> ``` ### 3. prevent的使用：阻止默认事件的发生 ```html \x3c!--prevent的使用：阻止默认事件的发生--\x3e <div @click="divEven" style="border:1px #188eee solid;">     <a href="#" @click.stop.prevent="aEven">百度链接</a> </div> ``` ### 4. self的使用：只有点击他本身时才去执行，点击他的子元素不去执行 ```html \x3c!--self的使用：只有点击他本身时才去执行，点击他的子元素不去执行--\x3e <div @click.self="divEven" style="border:1px #188eee solid;">     <a href="#" @click.prevent="aEven">百度链接</a> </div> ``` ### 5. capture的使用：触发捕获事件()先执行大盒子的事件，起执行小盒子的事件 ```html \x3c!--capture的使用：触发捕获事件()先执行大盒子的事件，起执行小盒子的事件--\x3e <div @click.capture="divEven" style="border:1px #188eee solid;">     <a href="#" @click.prevent="aEven">百度链接</a> </div> ``` '},{title:"【读书笔记】《JavaScript权威指南》第7章数组",path:"/posts/first.html",strippedContent:" > 第一次尝试用vuePress写博客"}]}}]);